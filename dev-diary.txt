12/11/17

haven't touched this project in a couple of weeks

recollection of current status:
drawing a board on the screen works
identifying and drawing playable cells works
identifying and drawing blocked cells works

currently working on:
implementing an "AI" (i.e. just a function that calculates all the possible moves for
the current board via brute force, compares all their scores, and picks the one with
the highest score)

current problem:
function is just totally broken
for a few reasons:

1) i need to sit down and write out, in english, how to find all possible moves (will
do that in a bit)
2) i'm just completely sucking at figuring out how to do the correct level of nesting?

like, moves should look like this

[
    [[an-x a-y] a-value]
    [[another-x another-y] a-value]
]

etc. but i think that my code currently doesn't do that, it has lists that are nested
too deeply or something.

i have this open in a tab, will read it now:
https://stuartsierra.com/2015/04/26/clojure-donts-concat

he says that concat is lazy and bad
and into is eager and good

what about https://stackoverflow.com/questions/5232350/clojure-semi-flattening-a-nested-sequence
they just say to use apply concat
or to use mapcat

ok anyway i think https://github.com/jeaye/orchestra will actually detect my bad nesting code
and alert me about it
so let's try to set that up
because spec instrumentation doesn't check :rets because of reasons

that was cool, orchestra found two bugs in my :rets

it also has a defn-spec macro that seems like it doesn't add all that much value over the
traditional way of annotating functions, so i'm gonna stick with s/fdef for now

ok let's try running the instrumented ai code to see if orchestra finds a spec bug

god this function is hideous

ok well i _had_ a spec error message but now it's gone, and i don't think i changed the code
so that's great

guess i gotta reread this function again

ok it's still hideous and broken but i think i made some progress

there was a mistake (?) in the implementation of find-runs
it wouldn't take the current cell into account, it was up to the caller to add the current
cell's value and update the runs' length if the cell's value was non-nil, and that seems bad
so anyway i fixed that

but the results of the ai function are still all fucked up, like this for instance

([[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]

etc

where [6 2] has the value 5, so 0 at [5 2] is fine but then putting 2 at [7 2] is not fine
so there are (at least) two categories of badness:
insane amount of duplication (no idea why yet), and
invalid moves being included in the output

so dig into those two things next time

==============

12/12/17

ok, i think the right place to start is to shrink down the board and de-randomize the hand for now
so just have a single cell with value 5 on the board (board remains same size, just has one non-nil cell)
and set the hand to be 4 5 1
this way there are a few valid moves: 4 5 1, 5, and 4 1. so ideally the function would be able
to find all of them, and all of their different arrangements. we'll see!
the idea is that this'll make things easier to reproduce, reason about, and step through

umm, i think it.. worked? that's unexpected

let's try it with hand 4 5 1 2; the 2 should never be contained in any valid move

ok that still worked, wow

anyway there's lots of duplication so let's start with that i guess

TODO at some point: make the board have 2 non-nil cells, and start thinking about xdir/ydir

hm i mean things are actually looking pretty good so far

i set hand to 4 5 1 2 3, and we get results like this

[[[5 6] 2] [[4 6] 3]]
 [[[5 6] 3] [[4 6] 2] [[3 6] 5]]
 [[[5 6] 5] [[4 6] 1] [[3 6] 4]]
 [[[5 6] 1] [[4 6] 4] [[3 6] 5]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 5] [[5 7] 3] [[5 8] 2]]
 [[[5 6] 1] [[5 7] 3] [[5 8] 4] [[5 9] 2]]
 [[[5 6] 2] [[5 7] 1] [[5 8] 3] [[5 9] 4]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 3] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 3] [[5 8] 4] [[5 9] 1]]
 [[[5 6] 4] [[5 7] 3] [[5 8] 2] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 4] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 1] [[5 7] 4] [[5 8] 5]]

note that it never tries suggesting a move with all five of those tiles in the hand,
because that would violate the no-runs-longer-than-5 rule
so that looks actually pretty good!

so i guess we should try increasing the size of the board and see if we can reproduce the
invalid-moves behavior. i'll also set the hand back down to 4 5 1

ha nice i tried just adding a single cell with value 4 under the 5-valued cell,
but assert-grid-valid blew up because that is indeed an invalid grid. niiice

ok this is looking good - but i'm seeing some duplication?!?!?!

 [[[6 5] 5]]
 [[[6 5] 5]]
 [[[6 9] 5]]
 [[[6 9] 5]]
 [[[7 6] 4] [[5 6] 1] [[4 6] 5]]
 [[[7 6] 5] [[5 6] 1] [[4 6] 4]]

that's part of the output when board has cells 5 4 1 and hand has 4 5 1.

note the repeated [6 5] 5s and [6 9] 5s. what gives?

this function was being invoked in a way that was different from what i expected/remembered
moving the set application up to the function's callsite, and also making
valid-moves-seen and move-so-far into sets, got rid of all duplication in the output
so at this point the function basically behaves exactly as you'd expect for this board and hand
so that's cool

but i bet it's gonna fail miserably when you've got a vertical and horizontal run,
that's the point at which we're going to have to think about xdir and ydir

so let's do that next time. add a horizontal run that intersects the current vertical run
at the top or bottom cell, and watch it generate incorrect moves,
and then think hard and write notes down here about xdir and ydir and make the code actually correct.
_then_ refactor this completely disgusting mess of code

did a quick profile just now for funsies, looks like about 88% of our time is spent
in stest/instrument right now, so that both tells us that a) instrumentation is as slow
as i remembered and b) the current function shouldn't be a complete non-starter on a bigger
board with a bigger hand. will need to investigate memoizing find-runs later on to see if
that helps / is necessary

==============

12/13/18

TODO idea for breaking up the big insane function when we include xdir/ydir conds

make a function like `are-runs-valid?` that takes the runs and xdir ydir
also returns false if either run is too long

ok, adding a horizontal row to the board, let's see what happens

ok yeah, as expected, we generate invalid moves

on a board like this

    5
    4
3 6 1

we try to place a 1 to the left of the 4 and a 5 to the right of the 4
which is fine horizontally, but fucked vertically, because that leaves you with a vertical
run with sum 7, which is obv not divisible by 5. so let's modify the code to deal with xdir/ydir

ok sick i think all-moves-for-cells works now

next up: reread the whole quinto.ai file and attempt to clean it up
and then document it

_eventually_, write code that actually makes these moves!
_also_, write code that scores a potential move!

ok so i just spent some time playing around with specter, i think it's cool
and i spent some time working on a score-move function
but i'm currently seeing at least two bugs in it

one: sometimes it reports scores that aren't a multiple of five

eg on the board given above, it says that placing a 2 above the 3 and a 5 below the 3
yields score 22, which is incorrect

it also says that placing a 5 above the 3 and a 2 below the 3 yields score 25, which is _also_ incorrect

nvm, fixed, looks like it was a mistake in the line where i was determining whether the move was horizontal or vertical

===========

12/14/17

currently seeing a bug:
on a board like this:

    5
    4
3 6 1

with a hand of just [5], the function never tries to place the 5 to the left or right of the preexisting 5
let's investigate that and figure out why

ok awesome, it looks like the bug was that we were throwing away results if you were in a
situation where your hand ran out of tiles. changing

(empty? available-cells-for-move)

to

(or (empty? available-cells-for-move)
    (empty? hand))

solved the problem.

ok i did some cleanup in quinto.ai, things are looking really good
gonna take a quick look at perf now

nothing obvious jumps out, and perf is acceptable atm when instrumentation is turned off

so next up:
display the hand on the screen
and add a button that, when pressed, causes the AI to make a move
distant future: allow user to make their own move, play against the AI

ok i messed with the ui, now there's a visible hand and a button

so next up, wire up the button!

also eventual todo: get quinto.ai to handle making the first move on an empty board

ok sick i wired up the button

next up: set things up so that the board starts off as empty, and have the AI be able
to handle making the first move on that empty board.

after that: add some sort of combat log that keeps track of moves' scores and the total score

after that: let the player play against the AI?

also do another cleanup pass on find-runs

========

12/15/17

right now my impelmentation of find-empty-cells looks like

(apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (nil? (get-in grid [x y]))]
             [x y]))))

i was curious about whether specter would be a good/natural fit for this, so i asked in slack
nathan says:

(select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST nil?) FIRST] grid)

which looks kind of insane to me? let's try it out and see what happens

ok yeah those two things do give equal results

so how the hell does this specter one work?

ok i think i get it
played around with a bunch of examples
the specter readme talks about collecting values
so what's happening there is, we use INDEXED-VALS to get a seq of [index value] pairs
then we _collect_ the FIRST part of that seq, which is the x value
and then we use LAST to navigate into the corresponding value, which is a column of the grid
so then we use INDEXED-VALS again to do the same thing so we can get y values
we use `(selected? LAST nil?)` to say:
if you're not looking at a cell whose value is nil, then bail.
and then we finally use FIRST to get the y value of any nil cells

and per nathan's explanation, the way that "collected values" work is that:
if you've been collecting any values throughout your selection, the result
of the selection is
(conj collected-values value-youve-navigated-to)
so this all makes sense. nice

ok, that was fun. is there anything else i should specterize?
spectrify?
make spectral?

lol i turned instrumentation back on and the browser locks up for thirty seconds
when you press the make-a-move button

couldn't find anything to specterize, added a docstring to find-runs but its implementation looks good

next up: start working on the ability for a player to make a move themselves
let them click on a green cell, then allow them to choose one of the tiles in their hand,
and mark it as used somehow. also allow them to back out of the move entirely or change specific parts (how?)

things i expect will be involved:
adding modes to the board
moving :hand to :player-1-hand, adding a :player-2-hand
adding core.async to html, so we can have a go-loop that's solely responsible for modifying the app's mode

one thing to think about, re: specter:
transform is the analogous operation to update-in, and it's supposed to be 80% faster
i actually have basically zero update-ins in this codebase, which is really unusual but makes sense
this thing's pretty simple

i mean it basically looks like he wants you to use specter instead of, like, everything?

he says that instead of

(map inc data)

you should use

(transform ALL inc data)

and of course `inc` can be replaced by any arbitrary function that operates on an element of the sequence
hm, he also has:

Remove nils from a nested sequence:
user> (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})
{:a [1 2 3]}

he uses setval there instead of select, because he wants to return the total modified data structure
{:a [1 2 3]} rather than just [1 2 3]

reading a bit more of the specter readme:

"Get all the numbers out of a data structure, no matter how they're nested:
user> (select (walker number?)
              {2 [1 2 [6 7]] :a 4 :c {:a 1 :d [2 nil]}})
[2 1 2 1 2 6 7 4]"

that's cool, walker looks useful
i wonder if you could do a similar thing using spec
you could say something like (walker #(s/valid? ::my-spec %)) or something
and thereby find all foos in your arbitrarily nested datastructure

this bit's pretty interesting:

"Append [:c :d] to every subsequence that has at least two even numbers:
user> (setval [ALL
               (selected? (filterer even?) (view count) (pred>= 2))
               END]
              [:c :d]
              [[1 2 3 4 5 6] [7 0 -1] [8 8] []])
[[1 2 3 4 5 6 :c :d] [7 0 -1] [8 8 :c :d] []]

When doing more involved transformations, you often find you lose context when navigating
deep within a data structure and need information "up" the data structure to perform the
transformation. Specter solves this problem by allowing you to collect values during navigation
to use in the transform function."

i ran into this when implementing find-empty-cells (or rather, when copy-pasting the implementation
that nathan handed to me), but that was just for selection - i haven't written any transforms yet

"The transform function receives as arguments all the collected values followed by the navigated to value."

makes sense, since that's how selection works too

it sure feels like we should be able to use specter for find-runs

ok yeah it looks like srange might do the trick

=> (select [(srange 0 13) ALL 5]
          (@app-state :grid))
[nil nil nil 5 5 7 3 nil nil nil nil nil nil]

; TODO what about right-to-left? i guess just reverse the sequence?

ok i specterized find-runs and now it runs noticeably slower!
because i'm doing a bunch of stuff outside of the specter query

here's the spectral version of run-in-direction that i came up with, the slow one i'm not going to go with:
(fn [xdir ydir]
   (let [selector (if (= xdir 0) [x ALL] [ALL y])
         origin-on-axis (if (= xdir 0) y x)
         values-on-axis (select selector grid)

         origin-on-axis (cond
                          (= xdir -1) (- (dec GRID-WIDTH) origin-on-axis)
                          (= ydir -1) (- (dec GRID-HEIGHT) origin-on-axis)
                          :else origin-on-axis)
         values-on-axis (if (or (= xdir -1) (= ydir -1))
                          (reverse values-on-axis)
                          values-on-axis)

         run (->> values-on-axis
                  (drop (inc origin-on-axis))
                  (take-while (comp not nil?)))]
     [(count run) (apply + run)]))

i'm sure the select part is fast, but then we do all this other stuff, and it's not noticeably nicer code

the preexisting solution is smaller and faster:

(fn [xdir ydir]
   (reduce (fn [[run-length run-sum] num-steps-in-direction]
             ; Find the position of the cell we're currently examining.
             (let [run-x (+ x (* xdir num-steps-in-direction))
                   run-y (+ y (* ydir num-steps-in-direction))]
               (if (or (not (cell-is-on-grid grid run-x run-y))
                       (nil? (get-in grid [run-x run-y])))
                 ; If the cell's value is nil or this position is off the grid, the run is over.
                 (reduced [run-length run-sum])
                 ; Otherwise, record this cell's value and continue following the run.
                 [(inc run-length)
                  (+ run-sum (get-in grid [run-x run-y]))])))
           [0 0]
           (map inc (range))))

again this is my fault, not specter's, and my specter version is just worse because
i don't know how to write specter code.

i think that i should try specterizing this again, except this time we do all of the upfront work
before the select, making the perfect path to pass to select.

things to look into:
transform reverse
path functions
if-path? is that a relevant thing here?

=======

12/16/17

ok let's take another look at find-runs

had some trouble figuring out how to use specter to select a row of data

i originally tried this

(select [(srange 2 7) 4]
          (@app-state :grid))

but it gives

[[nil nil nil nil 7 3 5 4 1 nil nil nil nil]]

which is super not what i want - in fact, it's actually a vertical _column_ rather than a row
which just doesn't make any sense, because i thought i was saying: give me everything
at y=4 where x is in range (2, 7).

but it looks like instead you need to do another ALL after you call srange in this case

(select [(srange 2 7) ALL 4]
          (@app-state :grid))

gives [8 2 3 5 7]

which is exactly what i wanted. neat. something to keep in mind when using srange; i'm not
sure i have a full understanding of what happened here, but that's ok for now, i'll figure
it out as i go

ok, doing this
(select [6 (srange 4 9)]
          (@app-state :grid))

gives [[7 3 5 4 1]]

but doing this
(select [6 (srange 4 9) ALL]
          (@app-state :grid))

gives [7 3 5 4 1]

so it basically looks like (srange) doesn't navigate you "down" one layer like ALL does
so after using srange, you have to use ALL again

ok at this point i've got something that's beginning to work but is kind of insane

(defn grid-range [start end direction]
  (srange (max start 0)
          (min end (if (= direction :horizontal)
                     GRID-WIDTH
                     GRID-HEIGHT))))

(comment
(let [x 6
      y 4]
  {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL
                       y]
                      (@app-state :grid))
   :down-run  (select [x
                       (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL]
                      (@app-state :grid))
   :left-run  (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL
                       y]
                      (@app-state :grid))
   :up-run    (select [x
                       (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL]
                      (@app-state :grid))})

  (select [(srange 2 6) ALL])

  (select [6 (srange 9 4) ALL]
          (@app-state :grid))

  )

and that isn't complete yet because we need to reverse the order of :up-run and :left run,
and then call (take-while nil a-run) on each of these

and i think we're left with something that's worse than what we started with.
so maybe specter isn't a good fit here

ok, putting that down for now, pending advice from #specter
no biggie

copy-pasting a section from a day or two ago:
next up: start working on the ability for a player to make a move themselves
let them click on a green cell, then allow them to choose one of the tiles in their hand,
and mark it as used somehow. also allow them to back out of the move entirely or change specific parts (how?)

things i expect will be involved:
adding modes to the board
moving :hand to :player-1-hand, adding a :player-2-hand
adding core.async to html, so we can have a go-loop that's solely responsible for modifying the app's mode

what's the best place to start, modes or core.async?
modes - just manually put the board into a specific mode when developing this

modes
-----

when you're in :assembling-move mode
:move-so-far is a list that tracks your selected cells/values

:available-cells is the list of [x y] positions that are valid options for
the next part of your move

:selected-cell is the cell you've clicked on

so you click on a green cell
you enter :assembling-move mode
the green cell turns orange (or something) and your hand is presented to you
you click on one of the tiles in your hand
the selected cell and the selected tile value are added to :move-so-far
the selected tile value is removed from your hand
at this point, SEVERAL cells can turn green - any playable cells that are neighbors of
the first cell in your move. this can be up to four cells!!!!
and those cells are all kept in the list :available-cells.

then you click on one of those green cells
the process above repeats
but once you select a tile from your hand, there's only AT MOST ONE available cell
and it's kept in :available-cells

so far assembling-move mode has data keys
:move-so-far
:selected-cell
:available-cells

and when you enter assembling-move mode, the controls box gains
a checkmark button
and a left-arrow button
and an X button

when we're waiting for a tile to be chosen, selected-cell is non-nil
after that, move-so-far is updated, selected-cell is set to nil, and available-cells are drawn

need to hammer this out a little bit, almost want a flow chart on a whiteboard
trying to keep the reagent code from being insane

let's come up with some example mode dicts

when you click on a green cell and enter assembling-move mode, we generate this mode dict:

{:mode/type :assembling-move
 :selected-cell [5 5]
 :available-cells []
 :move-so-far []}

in quinto.html we draw the selected cell as orange (or something), we stop drawing any other cell
as green, but we keep drawing blocked cells as red

then when you click on a tile in your hand, we remove it from your hand and generate this mode dict:

{:mode/type :assembling-move
 :selected-cell nil
 :available-cells [[5 4] [5 6] [6 5]]
 :move-so-far [[5 5] 8]}

in quinto.html, we draw the available cells as green and continue drawing blocked cells as red

then when you click on a green cell, we generate this mode dict:

{:mode/type :assembling-move
 :selected-cell [5 4]
 :available-cells []
 :move-so-far [[5 5] 8]}

we draw the selected cell as orange and stop drawing anything as green

continue until you confirm the move, at which point we go back to :default mode

temporary pause on modes
------------------------

temporary digression - specter
------------------------------

nathan says:

"""
@jrheard your use case is probably best handled with matrix-specific navigators

here's an excerpt from some code I have:
```(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-> structure :rows (nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (->Matrix (assoc rows row (assoc r col new-elem)))
      )))
```

you could also make a "submat" navigator that navigates you to a submatrix

then you could do something like `(select [(submat 4 2 8 2) ALL ALL] mat)` to get the "down run" (edited)

for a less flexible approach you could have a `submat-elems` function like so:
```(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-> structure(nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (assoc rows row (assoc r col new-elem))
      )))

(defn ^:direct-nav submat-elems [row col row2 col2]
  (reduce
    multi-path
    (for [r (range row (inc row2))
          c (range col (inc col2))]
      (matrix-elem r c)
      )))

(def data
  [[1   2   3   4]
   [5   6   7   8]
   [9   :a  :b  :c]
   [:d  :e  :f  :g]])

(select (submat-elems 1 1 3 1) data)
;; => [6 :a :e]
```

technically you don't really need `matrix-elem` and can just use `nthpath`
"""

=====

12/17/17

ok let's take a look at nathan's advice

taking a look at matrix-elem's select* operation:

=> (-> (@app-state :grid)
      (get 6)
      (get 4))
7

=> (select
    [(nthpath 6 4)]
    (@app-state :grid))

[7]

so like he says, we don't need matrix-elem, just nthpath and ALL

so let's look at what's going on in submat-elems

ok awesome, i poked around at it and ended up with

(defn ^:direct-nav grid-elems
  [x1 y1 x2 y2]
  (if (g/cell-is-on-grid x1 y1)
    (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
          y2 (bound-between y2 0 (dec GRID-HEIGHT))]

      (reduce
        multi-path
        (for [x (if (< x1 x2)
                  (range x1 (inc x2))
                  (reverse (range x2 (inc x1))))
              y (if (< y1 y2)
                  (range y1 (inc y2))
                  (reverse (range y2 (inc y1))))]
          (nthpath x y))))

    STOP))

which seems to be exactly what i wanted!

ok well it's exactly what i wanted but it's way slower

usage ended up looking like this

(fn [xdir ydir]
   (let [values-in-direction (select (grid-values (+ x xdir)
                                                  (+ y ydir)
                                                  (+ x (* xdir MAX-RUN-LENGTH))
                                                  (+ y (* ydir MAX-RUN-LENGTH)))
                                     grid)
         run-values (take-while (comp not nil?) values-in-direction)]
     [(count run-values) (apply + run-values)]))

asked nathan in #specter, he says:

"
it would be a lot faster as a first-class navigator
implementation would be similar to `ALL`, except in two dimensions
it would be easy to also avoid needing to do two `nth` per element, since you can do
every matching value in a row one after another
"

so, what's the deal with first-class navigators?

ALL looks like this:

(defnav
  ^{:doc "Navigate to every element of the collection. For maps navigates to
          a vector of `[key value]`."}
  ALL
  []
  (select* [this structure next-fn]
    (n/all-select structure next-fn))
  (transform* [this structure next-fn]
    (n/all-transform structure next-fn)))

per http://nathanmarz.com/blog/clojures-missing-piece.html,
a nav has "two codepaths, one for querying (select*) and one for transforming (transform*)"

"A navigator that navigates to multiple subvalues (like ALL) must call next-fn on each subvalue."

ok so it looks like srange might actually be a closer fit for this situation?

(defnav
  ^{:doc "Navigates to the subsequence bound by the indexes start (inclusive)
          and end (exclusive)"}
  srange
  [start end]
  (select* [this structure next-fn]
    (n/srange-select structure start end next-fn))
  (transform* [this structure next-fn]
    (n/srange-transform structure start end next-fn)))

here's what i said in slack

i ended up with this, it’s 4-5x faster than the previous specter approach but still _roughly_
(no benchmarks collected, going solely on how the app feels to use)  1.5-2x slower than the
reduce approach. it’s also kind of hideous but that’s my fault:
```(defnav
  grid-values-2
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (next-fn
             (if (cell-is-on-grid x1 y1)
               (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                     y2 (bound-between y2 0 (dec GRID-HEIGHT))]
                 (if (= x1 x2)
                   (let [column (nth structure x1)]
                     (if (< y1 y2)
                       (subvec column y1 (inc y2))
                       (reverse (subvec column y2 (inc y1)))))

                   (for [x (if (< x1 x2)
                             (range x1 (inc x2))
                             (reverse (range x2 (inc x1))))]
                     (-> structure
                         (nth x)
                         (nth y1)))))
               [])))

  (transform* [this structure next-fn]
              ; punting on this for now
              (assert false)))```
(edited)


i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind :smile:
hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster
perf is actually pretty acceptable when run through advanced compliation, nice (edited)
benchmarking stuff now; as you’d expect, that code runs pretty fast (~35ms in 1000000 runs) when x1 = x2,
but about 50x slower (~1400 ms in 1000000 runs) when x1 != x2 (edited)
so the codepath i need to focus on optimizing is

```(for [x (if (< x1 x2)
          (range x1 (inc x2))
          (reverse (range x2 (inc x1))))]
  (-> data
      (nth x)
      (nth y1)))```
. hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t
seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and
then call nth on that column to find our value

ok, things to try
1) replace the select* implementation with calls to `loop`
2) represent the grid as a 1d vector instead of a 2d vector

be sure to benchmark before and after

also benchmark multi next-fns vs single next-fn

single next-fn for whole collection, 50 executions of pick-move takes about 9300ms
multiple next-fn calls, one per item in the collection, no noticeable perf difference, still about 9300ms
maybe it makes more of a difference if you're selecting a ton of stuff, this just does at most 5 items

switching the along-the-x-axis case to two hand-rolled loops takes us down to 7200ms

next up: try a 1d vector

ok i tried that and it gave us zero speed boost!!!

presumably this is because vectors are implemented under the hood as trees, and so a 1d vector
doesn't guarantee you a contiguous block of memory, and so there's basically no difference between
a 1d vector and a 2d vector here

TODO read http://hypirion.com/musings/persistent-vector-performance

the perf with this hand-rolled loop is totally acceptable when advance-compiled so F it

ok so anyway read that article
and then tidy up the specter branch and merge it into master
and then get back to work on modes
