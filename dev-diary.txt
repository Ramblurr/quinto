12/11/17

haven't touched this project in a couple of weeks

recollection of current status:
drawing a board on the screen works
identifying and drawing playable cells works
identifying and drawing blocked cells works

currently working on:
implementing an "AI" (i.e. just a function that calculates all the possible moves for
the current board via brute force, compares all their scores, and picks the one with
the highest score)

current problem:
function is just totally broken
for a few reasons:

1) i need to sit down and write out, in english, how to find all possible moves (will
do that in a bit)
2) i'm just completely sucking at figuring out how to do the correct level of nesting?

like, moves should look like this

[
    [[an-x a-y] a-value]
    [[another-x another-y] a-value]
]

etc. but i think that my code currently doesn't do that, it has lists that are nested
too deeply or something.

i have this open in a tab, will read it now:
https://stuartsierra.com/2015/04/26/clojure-donts-concat

he says that concat is lazy and bad
and into is eager and good

what about https://stackoverflow.com/questions/5232350/clojure-semi-flattening-a-nested-sequence
they just say to use apply concat
or to use mapcat

ok anyway i think https://github.com/jeaye/orchestra will actually detect my bad nesting code
and alert me about it
so let's try to set that up
because spec instrumentation doesn't check :rets because of reasons

that was cool, orchestra found two bugs in my :rets

it also has a defn-spec macro that seems like it doesn't add all that much value over the
traditional way of annotating functions, so i'm gonna stick with s/fdef for now

ok let's try running the instrumented ai code to see if orchestra finds a spec bug

god this function is hideous

ok well i _had_ a spec error message but now it's gone, and i don't think i changed the code
so that's great

guess i gotta reread this function again

ok it's still hideous and broken but i think i made some progress

there was a mistake (?) in the implementation of find-runs
it wouldn't take the current cell into account, it was up to the caller to add the current
cell's value and update the runs' length if the cell's value was non-nil, and that seems bad
so anyway i fixed that

but the results of the ai function are still all fucked up, like this for instance

([[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]

etc

where [6 2] has the value 5, so 0 at [5 2] is fine but then putting 2 at [7 2] is not fine
so there are (at least) two categories of badness:
insane amount of duplication (no idea why yet), and
invalid moves being included in the output

so dig into those two things next time

==============

12/12/17

ok, i think the right place to start is to shrink down the board and de-randomize the hand for now
so just have a single cell with value 5 on the board (board remains same size, just has one non-nil cell)
and set the hand to be 4 5 1
this way there are a few valid moves: 4 5 1, 5, and 4 1. so ideally the function would be able
to find all of them, and all of their different arrangements. we'll see!
the idea is that this'll make things easier to reproduce, reason about, and step through

umm, i think it.. worked? that's unexpected

let's try it with hand 4 5 1 2; the 2 should never be contained in any valid move

ok that still worked, wow

anyway there's lots of duplication so let's start with that i guess

TODO at some point: make the board have 2 non-nil cells, and start thinking about xdir/ydir

hm i mean things are actually looking pretty good so far

i set hand to 4 5 1 2 3, and we get results like this

[[[5 6] 2] [[4 6] 3]]
 [[[5 6] 3] [[4 6] 2] [[3 6] 5]]
 [[[5 6] 5] [[4 6] 1] [[3 6] 4]]
 [[[5 6] 1] [[4 6] 4] [[3 6] 5]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 5] [[5 7] 3] [[5 8] 2]]
 [[[5 6] 1] [[5 7] 3] [[5 8] 4] [[5 9] 2]]
 [[[5 6] 2] [[5 7] 1] [[5 8] 3] [[5 9] 4]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 3] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 3] [[5 8] 4] [[5 9] 1]]
 [[[5 6] 4] [[5 7] 3] [[5 8] 2] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 4] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 1] [[5 7] 4] [[5 8] 5]]

note that it never tries suggesting a move with all five of those tiles in the hand,
because that would violate the no-runs-longer-than-5 rule
so that looks actually pretty good!

so i guess we should try increasing the size of the board and see if we can reproduce the
invalid-moves behavior. i'll also set the hand back down to 4 5 1

ha nice i tried just adding a single cell with value 4 under the 5-valued cell,
but assert-grid-valid blew up because that is indeed an invalid grid. niiice

ok this is looking good - but i'm seeing some duplication?!?!?!

 [[[6 5] 5]]
 [[[6 5] 5]]
 [[[6 9] 5]]
 [[[6 9] 5]]
 [[[7 6] 4] [[5 6] 1] [[4 6] 5]]
 [[[7 6] 5] [[5 6] 1] [[4 6] 4]]

that's part of the output when board has cells 5 4 1 and hand has 4 5 1.

note the repeated [6 5] 5s and [6 9] 5s. what gives?

this function was being invoked in a way that was different from what i expected/remembered
moving the set application up to the function's callsite, and also making
valid-moves-seen and move-so-far into sets, got rid of all duplication in the output
so at this point the function basically behaves exactly as you'd expect for this board and hand
so that's cool

but i bet it's gonna fail miserably when you've got a vertical and horizontal run,
that's the point at which we're going to have to think about xdir and ydir
