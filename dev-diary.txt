12/11/17

haven't touched this project in a couple of weeks

recollection of current status:
drawing a board on the screen works
identifying and drawing playable cells works
identifying and drawing blocked cells works

currently working on:
implementing an "AI" (i.e. just a function that calculates all the possible moves for
the current board via brute force, compares all their scores, and picks the one with
the highest score)

current problem:
function is just totally broken
for a few reasons:

1) i need to sit down and write out, in english, how to find all possible moves (will
do that in a bit)
2) i'm just completely sucking at figuring out how to do the correct level of nesting?

like, moves should look like this

[
    [[an-x a-y] a-value]
    [[another-x another-y] a-value]
]

etc. but i think that my code currently doesn't do that, it has lists that are nested
too deeply or something.

i have this open in a tab, will read it now:
https://stuartsierra.com/2015/04/26/clojure-donts-concat

he says that concat is lazy and bad
and into is eager and good

what about https://stackoverflow.com/questions/5232350/clojure-semi-flattening-a-nested-sequence
they just say to use apply concat
or to use mapcat

ok anyway i think https://github.com/jeaye/orchestra will actually detect my bad nesting code
and alert me about it
so let's try to set that up
because spec instrumentation doesn't check :rets because of reasons

that was cool, orchestra found two bugs in my :rets

it also has a defn-spec macro that seems like it doesn't add all that much value over the
traditional way of annotating functions, so i'm gonna stick with s/fdef for now

ok let's try running the instrumented ai code to see if orchestra finds a spec bug

god this function is hideous

ok well i _had_ a spec error message but now it's gone, and i don't think i changed the code
so that's great

guess i gotta reread this function again

ok it's still hideous and broken but i think i made some progress

there was a mistake (?) in the implementation of find-runs
it wouldn't take the current cell into account, it was up to the caller to add the current
cell's value and update the runs' length if the cell's value was non-nil, and that seems bad
so anyway i fixed that

but the results of the ai function are still all fucked up, like this for instance

([[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]

etc

where [6 2] has the value 5, so 0 at [5 2] is fine but then putting 2 at [7 2] is not fine
so there are (at least) two categories of badness:
insane amount of duplication (no idea why yet), and
invalid moves being included in the output

so dig into those two things next time

==============

12/12/17

ok, i think the right place to start is to shrink down the board and de-randomize the hand for now
so just have a single cell with value 5 on the board (board remains same size, just has one non-nil cell)
and set the hand to be 4 5 1
this way there are a few valid moves: 4 5 1, 5, and 4 1. so ideally the function would be able
to find all of them, and all of their different arrangements. we'll see!
the idea is that this'll make things easier to reproduce, reason about, and step through

umm, i think it.. worked? that's unexpected

let's try it with hand 4 5 1 2; the 2 should never be contained in any valid move

ok that still worked, wow

anyway there's lots of duplication so let's start with that i guess

TODO at some point: make the board have 2 non-nil cells, and start thinking about xdir/ydir

hm i mean things are actually looking pretty good so far

i set hand to 4 5 1 2 3, and we get results like this

[[[5 6] 2] [[4 6] 3]]
 [[[5 6] 3] [[4 6] 2] [[3 6] 5]]
 [[[5 6] 5] [[4 6] 1] [[3 6] 4]]
 [[[5 6] 1] [[4 6] 4] [[3 6] 5]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 5] [[5 7] 3] [[5 8] 2]]
 [[[5 6] 1] [[5 7] 3] [[5 8] 4] [[5 9] 2]]
 [[[5 6] 2] [[5 7] 1] [[5 8] 3] [[5 9] 4]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 3] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 3] [[5 8] 4] [[5 9] 1]]
 [[[5 6] 4] [[5 7] 3] [[5 8] 2] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 4] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 1] [[5 7] 4] [[5 8] 5]]

note that it never tries suggesting a move with all five of those tiles in the hand,
because that would violate the no-runs-longer-than-5 rule
so that looks actually pretty good!

so i guess we should try increasing the size of the board and see if we can reproduce the
invalid-moves behavior. i'll also set the hand back down to 4 5 1

ha nice i tried just adding a single cell with value 4 under the 5-valued cell,
but assert-grid-valid blew up because that is indeed an invalid grid. niiice

ok this is looking good - but i'm seeing some duplication?!?!?!

 [[[6 5] 5]]
 [[[6 5] 5]]
 [[[6 9] 5]]
 [[[6 9] 5]]
 [[[7 6] 4] [[5 6] 1] [[4 6] 5]]
 [[[7 6] 5] [[5 6] 1] [[4 6] 4]]

that's part of the output when board has cells 5 4 1 and hand has 4 5 1.

note the repeated [6 5] 5s and [6 9] 5s. what gives?

this function was being invoked in a way that was different from what i expected/remembered
moving the set application up to the function's callsite, and also making
valid-moves-seen and move-so-far into sets, got rid of all duplication in the output
so at this point the function basically behaves exactly as you'd expect for this board and hand
so that's cool

but i bet it's gonna fail miserably when you've got a vertical and horizontal run,
that's the point at which we're going to have to think about xdir and ydir

so let's do that next time. add a horizontal run that intersects the current vertical run
at the top or bottom cell, and watch it generate incorrect moves,
and then think hard and write notes down here about xdir and ydir and make the code actually correct.
_then_ refactor this completely disgusting mess of code

did a quick profile just now for funsies, looks like about 88% of our time is spent
in stest/instrument right now, so that both tells us that a) instrumentation is as slow
as i remembered and b) the current function shouldn't be a complete non-starter on a bigger
board with a bigger hand. will need to investigate memoizing find-runs later on to see if
that helps / is necessary

==============

12/13/18

TODO idea for breaking up the big insane function when we include xdir/ydir conds

make a function like `are-runs-valid?` that takes the runs and xdir ydir
also returns false if either run is too long

ok, adding a horizontal row to the board, let's see what happens

ok yeah, as expected, we generate invalid moves

on a board like this

    5
    4
3 6 1

we try to place a 1 to the left of the 4 and a 5 to the right of the 4
which is fine horizontally, but fucked vertically, because that leaves you with a vertical
run with sum 7, which is obv not divisible by 5. so let's modify the code to deal with xdir/ydir

ok sick i think all-moves-for-cells works now

next up: reread the whole quinto.ai file and attempt to clean it up
and then document it

_eventually_, write code that actually makes these moves!
_also_, write code that scores a potential move!

ok so i just spent some time playing around with specter, i think it's cool
and i spent some time working on a score-move function
but i'm currently seeing at least two bugs in it

one: sometimes it reports scores that aren't a multiple of five

eg on the board given above, it says that placing a 2 above the 3 and a 5 below the 3
yields score 22, which is incorrect

it also says that placing a 5 above the 3 and a 2 below the 3 yields score 25, which is _also_ incorrect

nvm, fixed, looks like it was a mistake in the line where i was determining whether the move was horizontal or vertical

===========

12/14/17

currently seeing a bug:
on a board like this:

    5
    4
3 6 1

with a hand of just [5], the function never tries to place the 5 to the left or right of the preexisting 5
let's investigate that and figure out why

ok awesome, it looks like the bug was that we were throwing away results if you were in a
situation where your hand ran out of tiles. changing

(empty? available-cells-for-move)

to

(or (empty? available-cells-for-move)
    (empty? hand))

solved the problem.

ok i did some cleanup in quinto.ai, things are looking really good
gonna take a quick look at perf now

nothing obvious jumps out, and perf is acceptable atm when instrumentation is turned off

so next up:
display the hand on the screen
and add a button that, when pressed, causes the AI to make a move
distant future: allow user to make their own move, play against the AI

ok i messed with the ui, now there's a visible hand and a button

so next up, wire up the button!

also eventual todo: get quinto.ai to handle making the first move on an empty board

ok sick i wired up the button

next up: set things up so that the board starts off as empty, and have the AI be able
to handle making the first move on that empty board.

after that: add some sort of combat log that keeps track of moves' scores and the total score

after that: let the player play against the AI?

also do another cleanup pass on find-runs

========

12/15/17

right now my impelmentation of find-empty-cells looks like

(apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (nil? (get-in grid [x y]))]
             [x y]))))

i was curious about whether specter would be a good/natural fit for this, so i asked in slack
nathan says:

(select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST nil?) FIRST] grid)

which looks kind of insane to me? let's try it out and see what happens

ok yeah those two things do give equal results

so how the hell does this specter one work?

ok i think i get it
played around with a bunch of examples
the specter readme talks about collecting values
so what's happening there is, we use INDEXED-VALS to get a seq of [index value] pairs
then we _collect_ the FIRST part of that seq, which is the x value
and then we use LAST to navigate into the corresponding value, which is a column of the grid
so then we use INDEXED-VALS again to do the same thing so we can get y values
we use `(selected? LAST nil?)` to say:
if you're not looking at a cell whose value is nil, then bail.
and then we finally use FIRST to get the y value of any nil cells

and per nathan's explanation, the way that "collected values" work is that:
if you've been collecting any values throughout your selection, the result
of the selection is
(conj collected-values value-youve-navigated-to)
so this all makes sense. nice

ok, that was fun. is there anything else i should specterize?
spectrify?
make spectral?

lol i turned instrumentation back on and the browser locks up for thirty seconds
when you press the make-a-move button

couldn't find anything to specterize, added a docstring to find-runs but its implementation looks good



