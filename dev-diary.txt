12/11/17

haven't touched this project in a couple of weeks

recollection of current status:
drawing a board on the screen works
identifying and drawing playable cells works
identifying and drawing blocked cells works

currently working on:
implementing an "AI" (i.e. just a function that calculates all the possible moves for
the current board via brute force, compares all their scores, and picks the one with
the highest score)

current problem:
function is just totally broken
for a few reasons:

1) i need to sit down and write out, in english, how to find all possible moves (will
do that in a bit)
2) i'm just completely sucking at figuring out how to do the correct level of nesting?

like, moves should look like this

[
    [[an-x a-y] a-value]
    [[another-x another-y] a-value]
]

etc. but i think that my code currently doesn't do that, it has lists that are nested
too deeply or something.

i have this open in a tab, will read it now:
https://stuartsierra.com/2015/04/26/clojure-donts-concat

he says that concat is lazy and bad
and into is eager and good

what about https://stackoverflow.com/questions/5232350/clojure-semi-flattening-a-nested-sequence
they just say to use apply concat
or to use mapcat

ok anyway i think https://github.com/jeaye/orchestra will actually detect my bad nesting code
and alert me about it
so let's try to set that up
because spec instrumentation doesn't check :rets because of reasons

that was cool, orchestra found two bugs in my :rets

it also has a defn-spec macro that seems like it doesn't add all that much value over the
traditional way of annotating functions, so i'm gonna stick with s/fdef for now

ok let's try running the instrumented ai code to see if orchestra finds a spec bug

god this function is hideous

ok well i _had_ a spec error message but now it's gone, and i don't think i changed the code
so that's great

guess i gotta reread this function again

ok it's still hideous and broken but i think i made some progress

there was a mistake (?) in the implementation of find-runs
it wouldn't take the current cell into account, it was up to the caller to add the current
cell's value and update the runs' length if the cell's value was non-nil, and that seems bad
so anyway i fixed that

but the results of the ai function are still all fucked up, like this for instance

([[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 2]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 7]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]
 [[[5 2] 0]]
 [[[5 2] 0] [[7 2] 9]]

etc

where [6 2] has the value 5, so 0 at [5 2] is fine but then putting 2 at [7 2] is not fine
so there are (at least) two categories of badness:
insane amount of duplication (no idea why yet), and
invalid moves being included in the output

so dig into those two things next time

==============

12/12/17

ok, i think the right place to start is to shrink down the board and de-randomize the hand for now
so just have a single cell with value 5 on the board (board remains same size, just has one non-nil cell)
and set the hand to be 4 5 1
this way there are a few valid moves: 4 5 1, 5, and 4 1. so ideally the function would be able
to find all of them, and all of their different arrangements. we'll see!
the idea is that this'll make things easier to reproduce, reason about, and step through

umm, i think it.. worked? that's unexpected

let's try it with hand 4 5 1 2; the 2 should never be contained in any valid move

ok that still worked, wow

anyway there's lots of duplication so let's start with that i guess

DONE at some point: make the board have 2 non-nil cells, and start thinking about xdir/ydir

hm i mean things are actually looking pretty good so far

i set hand to 4 5 1 2 3, and we get results like this

[[[5 6] 2] [[4 6] 3]]
 [[[5 6] 3] [[4 6] 2] [[3 6] 5]]
 [[[5 6] 5] [[4 6] 1] [[3 6] 4]]
 [[[5 6] 1] [[4 6] 4] [[3 6] 5]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 5] [[5 7] 3] [[5 8] 2]]
 [[[5 6] 1] [[5 7] 3] [[5 8] 4] [[5 9] 2]]
 [[[5 6] 2] [[5 7] 1] [[5 8] 3] [[5 9] 4]]
 [[[5 6] 4] [[5 7] 2] [[5 8] 3] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 3] [[5 8] 4] [[5 9] 1]]
 [[[5 6] 4] [[5 7] 3] [[5 8] 2] [[5 9] 1]]
 [[[5 6] 2] [[5 7] 4] [[5 8] 1] [[5 9] 3]]
 [[[5 6] 1] [[5 7] 4] [[5 8] 5]]

note that it never tries suggesting a move with all five of those tiles in the hand,
because that would violate the no-runs-longer-than-5 rule
so that looks actually pretty good!

so i guess we should try increasing the size of the board and see if we can reproduce the
invalid-moves behavior. i'll also set the hand back down to 4 5 1

ha nice i tried just adding a single cell with value 4 under the 5-valued cell,
but assert-grid-valid blew up because that is indeed an invalid grid. niiice

ok this is looking good - but i'm seeing some duplication?!?!?!

 [[[6 5] 5]]
 [[[6 5] 5]]
 [[[6 9] 5]]
 [[[6 9] 5]]
 [[[7 6] 4] [[5 6] 1] [[4 6] 5]]
 [[[7 6] 5] [[5 6] 1] [[4 6] 4]]

that's part of the output when board has cells 5 4 1 and hand has 4 5 1.

note the repeated [6 5] 5s and [6 9] 5s. what gives?

this function was being invoked in a way that was different from what i expected/remembered
moving the set application up to the function's callsite, and also making
valid-moves-seen and move-so-far into sets, got rid of all duplication in the output
so at this point the function basically behaves exactly as you'd expect for this board and hand
so that's cool

but i bet it's gonna fail miserably when you've got a vertical and horizontal run,
that's the point at which we're going to have to think about xdir and ydir

so let's do that next time. add a horizontal run that intersects the current vertical run
at the top or bottom cell, and watch it generate incorrect moves,
and then think hard and write notes down here about xdir and ydir and make the code actually correct.
_then_ refactor this completely disgusting mess of code

did a quick profile just now for funsies, looks like about 88% of our time is spent
in stest/instrument right now, so that both tells us that a) instrumentation is as slow
as i remembered and b) the current function shouldn't be a complete non-starter on a bigger
board with a bigger hand. will need to investigate memoizing find-runs later on to see if
that helps / is necessary

==============

12/13/18

DONE idea for breaking up the big insane function when we include xdir/ydir conds

make a function like `are-runs-valid?` that takes the runs and xdir ydir
also returns false if either run is too long

ok, adding a horizontal row to the board, let's see what happens

ok yeah, as expected, we generate invalid moves

on a board like this

    5
    4
3 6 1

we try to place a 1 to the left of the 4 and a 5 to the right of the 4
which is fine horizontally, but fucked vertically, because that leaves you with a vertical
run with sum 7, which is obv not divisible by 5. so let's modify the code to deal with xdir/ydir

ok sick i think all-moves-for-cells works now

next up: reread the whole quinto.ai file and attempt to clean it up
and then document it

_eventually_, write code that actually makes these moves!
_also_, write code that scores a potential move!

ok so i just spent some time playing around with specter, i think it's cool
and i spent some time working on a score-move function
but i'm currently seeing at least two bugs in it

one: sometimes it reports scores that aren't a multiple of five

eg on the board given above, it says that placing a 2 above the 3 and a 5 below the 3
yields score 22, which is incorrect

it also says that placing a 5 above the 3 and a 2 below the 3 yields score 25, which is _also_ incorrect

nvm, fixed, looks like it was a mistake in the line where i was determining whether the move was horizontal or vertical

===========

12/14/17

currently seeing a bug:
on a board like this:

    5
    4
3 6 1

with a hand of just [5], the function never tries to place the 5 to the left or right of the preexisting 5
let's investigate that and figure out why

ok awesome, it looks like the bug was that we were throwing away results if you were in a
situation where your hand ran out of tiles. changing

(empty? available-cells-for-move)

to

(or (empty? available-cells-for-move)
    (empty? hand))

solved the problem.

ok i did some cleanup in quinto.ai, things are looking really good
gonna take a quick look at perf now

nothing obvious jumps out, and perf is acceptable atm when instrumentation is turned off

so next up:
display the hand on the screen
and add a button that, when pressed, causes the AI to make a move
distant future: allow user to make their own move, play against the AI

ok i messed with the ui, now there's a visible hand and a button

so next up, wire up the button!

also eventual DONE: get quinto.ai to handle making the first move on an empty board

ok sick i wired up the button

next up: set things up so that the board starts off as empty, and have the AI be able
to handle making the first move on that empty board.

after that: add some sort of combat log that keeps track of moves' scores and the total score

after that: let the player play against the AI?

also do another cleanup pass on find-runs

========

12/15/17

right now my impelmentation of find-empty-cells looks like

(apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (nil? (get-in grid [x y]))]
             [x y]))))

i was curious about whether specter would be a good/natural fit for this, so i asked in slack
nathan says:

(select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST nil?) FIRST] grid)

which looks kind of insane to me? let's try it out and see what happens

ok yeah those two things do give equal results

so how the hell does this specter one work?

ok i think i get it
played around with a bunch of examples
the specter readme talks about collecting values
so what's happening there is, we use INDEXED-VALS to get a seq of [index value] pairs
then we _collect_ the FIRST part of that seq, which is the x value
and then we use LAST to navigate into the corresponding value, which is a column of the grid
so then we use INDEXED-VALS again to do the same thing so we can get y values
we use `(selected? LAST nil?)` to say:
if you're not looking at a cell whose value is nil, then bail.
and then we finally use FIRST to get the y value of any nil cells

and per nathan's explanation, the way that "collected values" work is that:
if you've been collecting any values throughout your selection, the result
of the selection is
(conj collected-values value-youve-navigated-to)
so this all makes sense. nice

ok, that was fun. is there anything else i should specterize?
spectrify?
make spectral?

lol i turned instrumentation back on and the browser locks up for thirty seconds
when you press the make-a-move button

couldn't find anything to specterize, added a docstring to find-runs but its implementation looks good

next up: start working on the ability for a player to make a move themselves
let them click on a green cell, then allow them to choose one of the tiles in their hand,
and mark it as used somehow. also allow them to back out of the move entirely or change specific parts (how?)

things i expect will be involved:
adding modes to the board
moving :hand to :player-1-hand, adding a :player-2-hand
adding core.async to html, so we can have a go-loop that's solely responsible for modifying the app's mode

one thing to think about, re: specter:
transform is the analogous operation to update-in, and it's supposed to be 80% faster
i actually have basically zero update-ins in this codebase, which is really unusual but makes sense
this thing's pretty simple

i mean it basically looks like he wants you to use specter instead of, like, everything?

he says that instead of

(map inc data)

you should use

(transform ALL inc data)

and of course `inc` can be replaced by any arbitrary function that operates on an element of the sequence
hm, he also has:

Remove nils from a nested sequence:
user> (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})
{:a [1 2 3]}

he uses setval there instead of select, because he wants to return the total modified data structure
{:a [1 2 3]} rather than just [1 2 3]

reading a bit more of the specter readme:

"Get all the numbers out of a data structure, no matter how they're nested:
user> (select (walker number?)
              {2 [1 2 [6 7]] :a 4 :c {:a 1 :d [2 nil]}})
[2 1 2 1 2 6 7 4]"

that's cool, walker looks useful
i wonder if you could do a similar thing using spec
you could say something like (walker #(s/valid? ::my-spec %)) or something
and thereby find all foos in your arbitrarily nested datastructure

this bit's pretty interesting:

"Append [:c :d] to every subsequence that has at least two even numbers:
user> (setval [ALL
               (selected? (filterer even?) (view count) (pred>= 2))
               END]
              [:c :d]
              [[1 2 3 4 5 6] [7 0 -1] [8 8] []])
[[1 2 3 4 5 6 :c :d] [7 0 -1] [8 8 :c :d] []]

When doing more involved transformations, you often find you lose context when navigating
deep within a data structure and need information "up" the data structure to perform the
transformation. Specter solves this problem by allowing you to collect values during navigation
to use in the transform function."

i ran into this when implementing find-empty-cells (or rather, when copy-pasting the implementation
that nathan handed to me), but that was just for selection - i haven't written any transforms yet

"The transform function receives as arguments all the collected values followed by the navigated to value."

makes sense, since that's how selection works too

it sure feels like we should be able to use specter for find-runs

ok yeah it looks like srange might do the trick

=> (select [(srange 0 13) ALL 5]
          (@app-state :grid))
[nil nil nil 5 5 7 3 nil nil nil nil nil nil]

; DONE what about right-to-left? i guess just reverse the sequence?

ok i specterized find-runs and now it runs noticeably slower!
because i'm doing a bunch of stuff outside of the specter query

here's the spectral version of run-in-direction that i came up with, the slow one i'm not going to go with:
(fn [xdir ydir]
   (let [selector (if (= xdir 0) [x ALL] [ALL y])
         origin-on-axis (if (= xdir 0) y x)
         values-on-axis (select selector grid)

         origin-on-axis (cond
                          (= xdir -1) (- (dec GRID-WIDTH) origin-on-axis)
                          (= ydir -1) (- (dec GRID-HEIGHT) origin-on-axis)
                          :else origin-on-axis)
         values-on-axis (if (or (= xdir -1) (= ydir -1))
                          (reverse values-on-axis)
                          values-on-axis)

         run (->> values-on-axis
                  (drop (inc origin-on-axis))
                  (take-while (comp not nil?)))]
     [(count run) (apply + run)]))

i'm sure the select part is fast, but then we do all this other stuff, and it's not noticeably nicer code

the preexisting solution is smaller and faster:

(fn [xdir ydir]
   (reduce (fn [[run-length run-sum] num-steps-in-direction]
             ; Find the position of the cell we're currently examining.
             (let [run-x (+ x (* xdir num-steps-in-direction))
                   run-y (+ y (* ydir num-steps-in-direction))]
               (if (or (not (cell-is-on-grid grid run-x run-y))
                       (nil? (get-in grid [run-x run-y])))
                 ; If the cell's value is nil or this position is off the grid, the run is over.
                 (reduced [run-length run-sum])
                 ; Otherwise, record this cell's value and continue following the run.
                 [(inc run-length)
                  (+ run-sum (get-in grid [run-x run-y]))])))
           [0 0]
           (map inc (range))))

again this is my fault, not specter's, and my specter version is just worse because
i don't know how to write specter code.

i think that i should try specterizing this again, except this time we do all of the upfront work
before the select, making the perfect path to pass to select.

things to look into:
transform reverse
path functions
if-path? is that a relevant thing here?

=======

12/16/17

ok let's take another look at find-runs

had some trouble figuring out how to use specter to select a row of data

i originally tried this

(select [(srange 2 7) 4]
          (@app-state :grid))

but it gives

[[nil nil nil nil 7 3 5 4 1 nil nil nil nil]]

which is super not what i want - in fact, it's actually a vertical _column_ rather than a row
which just doesn't make any sense, because i thought i was saying: give me everything
at y=4 where x is in range (2, 7).

but it looks like instead you need to do another ALL after you call srange in this case

(select [(srange 2 7) ALL 4]
          (@app-state :grid))

gives [8 2 3 5 7]

which is exactly what i wanted. neat. something to keep in mind when using srange; i'm not
sure i have a full understanding of what happened here, but that's ok for now, i'll figure
it out as i go

ok, doing this
(select [6 (srange 4 9)]
          (@app-state :grid))

gives [[7 3 5 4 1]]

but doing this
(select [6 (srange 4 9) ALL]
          (@app-state :grid))

gives [7 3 5 4 1]

so it basically looks like (srange) doesn't navigate you "down" one layer like ALL does
so after using srange, you have to use ALL again

ok at this point i've got something that's beginning to work but is kind of insane

(defn grid-range [start end direction]
  (srange (max start 0)
          (min end (if (= direction :horizontal)
                     GRID-WIDTH
                     GRID-HEIGHT))))

(comment
(let [x 6
      y 4]
  {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL
                       y]
                      (@app-state :grid))
   :down-run  (select [x
                       (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL]
                      (@app-state :grid))
   :left-run  (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL
                       y]
                      (@app-state :grid))
   :up-run    (select [x
                       (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL]
                      (@app-state :grid))})

  (select [(srange 2 6) ALL])

  (select [6 (srange 9 4) ALL]
          (@app-state :grid))

  )

and that isn't complete yet because we need to reverse the order of :up-run and :left run,
and then call (take-while nil a-run) on each of these

and i think we're left with something that's worse than what we started with.
so maybe specter isn't a good fit here

ok, putting that down for now, pending advice from #specter
no biggie

copy-pasting a section from a day or two ago:
next up: start working on the ability for a player to make a move themselves
let them click on a green cell, then allow them to choose one of the tiles in their hand,
and mark it as used somehow. also allow them to back out of the move entirely or change specific parts (how?)

things i expect will be involved:
adding modes to the board
moving :hand to :player-1-hand, adding a :player-2-hand
adding core.async to html, so we can have a go-loop that's solely responsible for modifying the app's mode

what's the best place to start, modes or core.async?
modes - just manually put the board into a specific mode when developing this

modes
-----

when you're in :assembling-move mode
:move-so-far is a list that tracks your selected cells/values

:available-cells is the list of [x y] positions that are valid options for
the next part of your move

:selected-cell is the cell you've clicked on

so you click on a green cell
you enter :assembling-move mode
the green cell turns orange (or something) and your hand is presented to you
you click on one of the tiles in your hand
the selected cell and the selected tile value are added to :move-so-far
the selected tile value is removed from your hand
at this point, SEVERAL cells can turn green - any playable cells that are neighbors of
the first cell in your move. this can be up to four cells!!!!
and those cells are all kept in the list :available-cells.

then you click on one of those green cells
the process above repeats
but once you select a tile from your hand, there's only AT MOST ONE available cell
and it's kept in :available-cells

so far assembling-move mode has data keys
:move-so-far
:selected-cell
:available-cells

and when you enter assembling-move mode, the controls box gains
a checkmark button
and a left-arrow button
and an X button

when we're waiting for a tile to be chosen, selected-cell is non-nil
after that, move-so-far is updated, selected-cell is set to nil, and available-cells are drawn

need to hammer this out a little bit, almost want a flow chart on a whiteboard
trying to keep the reagent code from being insane

let's come up with some example mode dicts

when you click on a green cell and enter assembling-move mode, we generate this mode dict:

{:mode/type :assembling-move
 :selected-cell [5 5]
 :available-cells []
 :move-so-far []}

in quinto.html we draw the selected cell as orange (or something), we stop drawing any other cell
as green, but we keep drawing blocked cells as red

then when you click on a tile in your hand, we remove it from your hand and generate this mode dict:

{:mode/type :assembling-move
 :selected-cell nil
 :available-cells [[5 4] [5 6] [6 5]]
 :move-so-far [[5 5] 8]}

in quinto.html, we draw the available cells as green and continue drawing blocked cells as red

then when you click on a green cell, we generate this mode dict:

{:mode/type :assembling-move
 :selected-cell [5 4]
 :available-cells []
 :move-so-far [[5 5] 8]}

we draw the selected cell as orange and stop drawing anything as green

continue until you confirm the move, at which point we go back to :default mode

temporary pause on modes
------------------------

temporary digression - specter
------------------------------

nathan says:

"""
@jrheard your use case is probably best handled with matrix-specific navigators

here's an excerpt from some code I have:
```(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-> structure :rows (nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (->Matrix (assoc rows row (assoc r col new-elem)))
      )))
```

you could also make a "submat" navigator that navigates you to a submatrix

then you could do something like `(select [(submat 4 2 8 2) ALL ALL] mat)` to get the "down run" (edited)

for a less flexible approach you could have a `submat-elems` function like so:
```(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-> structure(nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (assoc rows row (assoc r col new-elem))
      )))

(defn ^:direct-nav submat-elems [row col row2 col2]
  (reduce
    multi-path
    (for [r (range row (inc row2))
          c (range col (inc col2))]
      (matrix-elem r c)
      )))

(def data
  [[1   2   3   4]
   [5   6   7   8]
   [9   :a  :b  :c]
   [:d  :e  :f  :g]])

(select (submat-elems 1 1 3 1) data)
;; => [6 :a :e]
```

technically you don't really need `matrix-elem` and can just use `nthpath`
"""

=====

12/17/17

ok let's take a look at nathan's advice

taking a look at matrix-elem's select* operation:

=> (-> (@app-state :grid)
      (get 6)
      (get 4))
7

=> (select
    [(nthpath 6 4)]
    (@app-state :grid))

[7]

so like he says, we don't need matrix-elem, just nthpath and ALL

so let's look at what's going on in submat-elems

ok awesome, i poked around at it and ended up with

(defn ^:direct-nav grid-elems
  [x1 y1 x2 y2]
  (if (g/cell-is-on-grid x1 y1)
    (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
          y2 (bound-between y2 0 (dec GRID-HEIGHT))]

      (reduce
        multi-path
        (for [x (if (< x1 x2)
                  (range x1 (inc x2))
                  (reverse (range x2 (inc x1))))
              y (if (< y1 y2)
                  (range y1 (inc y2))
                  (reverse (range y2 (inc y1))))]
          (nthpath x y))))

    STOP))

which seems to be exactly what i wanted!

ok well it's exactly what i wanted but it's way slower

usage ended up looking like this

(fn [xdir ydir]
   (let [values-in-direction (select (grid-values (+ x xdir)
                                                  (+ y ydir)
                                                  (+ x (* xdir MAX-RUN-LENGTH))
                                                  (+ y (* ydir MAX-RUN-LENGTH)))
                                     grid)
         run-values (take-while (comp not nil?) values-in-direction)]
     [(count run-values) (apply + run-values)]))

asked nathan in #specter, he says:

"
it would be a lot faster as a first-class navigator
implementation would be similar to `ALL`, except in two dimensions
it would be easy to also avoid needing to do two `nth` per element, since you can do
every matching value in a row one after another
"

so, what's the deal with first-class navigators?

ALL looks like this:

(defnav
  ^{:doc "Navigate to every element of the collection. For maps navigates to
          a vector of `[key value]`."}
  ALL
  []
  (select* [this structure next-fn]
    (n/all-select structure next-fn))
  (transform* [this structure next-fn]
    (n/all-transform structure next-fn)))

per http://nathanmarz.com/blog/clojures-missing-piece.html,
a nav has "two codepaths, one for querying (select*) and one for transforming (transform*)"

"A navigator that navigates to multiple subvalues (like ALL) must call next-fn on each subvalue."

ok so it looks like srange might actually be a closer fit for this situation?

(defnav
  ^{:doc "Navigates to the subsequence bound by the indexes start (inclusive)
          and end (exclusive)"}
  srange
  [start end]
  (select* [this structure next-fn]
    (n/srange-select structure start end next-fn))
  (transform* [this structure next-fn]
    (n/srange-transform structure start end next-fn)))

here's what i said in slack

i ended up with this, it’s 4-5x faster than the previous specter approach but still _roughly_
(no benchmarks collected, going solely on how the app feels to use)  1.5-2x slower than the
reduce approach. it’s also kind of hideous but that’s my fault:
```(defnav
  grid-values-2
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (next-fn
             (if (cell-is-on-grid x1 y1)
               (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                     y2 (bound-between y2 0 (dec GRID-HEIGHT))]
                 (if (= x1 x2)
                   (let [column (nth structure x1)]
                     (if (< y1 y2)
                       (subvec column y1 (inc y2))
                       (reverse (subvec column y2 (inc y1)))))

                   (for [x (if (< x1 x2)
                             (range x1 (inc x2))
                             (reverse (range x2 (inc x1))))]
                     (-> structure
                         (nth x)
                         (nth y1)))))
               [])))

  (transform* [this structure next-fn]
              ; punting on this for now
              (assert false)))```
(edited)


i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind :smile:
hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster
perf is actually pretty acceptable when run through advanced compliation, nice (edited)
benchmarking stuff now; as you’d expect, that code runs pretty fast (~35ms in 1000000 runs) when x1 = x2,
but about 50x slower (~1400 ms in 1000000 runs) when x1 != x2 (edited)
so the codepath i need to focus on optimizing is

```(for [x (if (< x1 x2)
          (range x1 (inc x2))
          (reverse (range x2 (inc x1))))]
  (-> data
      (nth x)
      (nth y1)))```
. hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t
seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and
then call nth on that column to find our value

ok, things to try
1) replace the select* implementation with calls to `loop`
2) represent the grid as a 1d vector instead of a 2d vector

be sure to benchmark before and after

also benchmark multi next-fns vs single next-fn

=========

12/18/17

single next-fn for whole collection, 50 executions of pick-move takes about 9300ms
multiple next-fn calls, one per item in the collection, no noticeable perf difference, still about 9300ms
maybe it makes more of a difference if you're selecting a ton of stuff, this just does at most 5 items

switching the along-the-x-axis case to two hand-rolled loops takes us down to 7200ms

next up: try a 1d vector

ok i tried that and it gave us zero speed boost!!!

presumably this is because vectors are implemented under the hood as trees, and so a 1d vector
doesn't guarantee you a contiguous block of memory, and so there's basically no difference between
a 1d vector and a 2d vector here

DONE read http://hypirion.com/musings/persistent-vector-performance

the perf with this hand-rolled loop is totally acceptable when advance-compiled so F it

ok so anyway read that article
and then tidy up the specter branch and merge it into master
and then get back to work on modes

memoizing find-runs gives us a 50% speedup, which is cool! not insane or even
that noticeable, but still very welcome!

http://blog.fikesfarm.com/posts/2016-01-20-self-calls-type-hints-and-memoization.html

looks like you have to be careful when memoizing recurisve functions in cljs

what if all-moves-for-cells-and-hand used a transient grid?
you'd have to undo your change after every branch
and it's not a 1-line change to make a 2d vector transient
and there isn't all _that_ much modification, most of the work is in find-runs
so whatever

ok whatever stop thinking about performance
perf is fine
particularly when advance compiled
just think about modes now

ok so modes have been going well so far
right now my next thing to do is to recalculate :mode :available-cells whenever you place a tile
DONE: that
will be tricky when your move crosses one or more preexisting tiles

after second tile placed:
figure out what direction you're going in, then select the cells in that direction
until you find your first non-nil one (up until max run length)

after first cell placed:
same as above, but for each of the four cardinal directions

=====

12/19/17

spent most of today so far continuing to work on assembling-move mode
added code that finds the next playable cells for a move
it's mostly working but i'm tracking down some weird crash that happens when
you've picked a cell, then selected a tile, then picked another cell, then you select another tile
we crash in find-next-open-cells-for-move, something about how you can't call nth on a Number
not obvious to me where that nth call is actually happening though

ok duh it was this, i was doing

(if (= (count move) 1)
    [[-1 0] [1 0] [0 -1] [0 1]]
    (move-direction move))

when i should have been doing

(if (= (count move) 1)
    [[-1 0] [1 0] [0 -1] [0 1]]
    [(move-direction move)])

ok now it's looking like direction-finding behavior is a bit too strict
it should be vertical moves and horizontal moves, not up/left/down/right moves

unrelated DONE - maybe some sort of :animate-computer-move mode, which flashes one move
of the tile at a time, with a one-second pause inbetween each part of the move?
you could actually have a generic :animation mode, and the mode dict has any data
that quinto.html needs in order to draw the animation
that could have worked in cljstone too i think, interesting

DONE replace "make a move" button with checkmark, left arrow, and X

DONE consider putting goog analytics tag on the page before publishing eventual blog post

DONE if a tile's in assembling mode's :move-so-far, draw it in a different color

next up: implement back button

ok back button's done
ran into an interesting programming error just now

if you have this board

1 7 7
    5
8 2 3 7

it's marked as invalid, but it should be marked as valid
this is because of a bug in is-grid-valid? (AND LIKELY ELSEWHERE)
having to do with the cells inbetween the 1 and 8, and between the 7 and 2
DONE FIX THAT


=========

12/20/17

DONE - sometimes the hand isn't refilled with enough tiles. i think this happens
when you make a move with dupes in it, eg two 7s

let's fix that first

oh, it was a simple bug in quinto.modes, we were remove-iteming in both select-tile
and confirm-move. just removed the remove-item from confirm-move, ez

ok the gap problem in is-grid-valid? was an easy fix, nice
just added a (nil? (get-in grid [x y])) to make it so that nil cells are fine

ok sick so now we've just gotta do:
1) score tracking
2) let the player play against the ai

anyway this is stable enough to merge into master so let's do that

ok score tracking was easy

now let's separate :hand out into :player-hand and :ai-hand
and add an :ai-scores

ok, that was easy

now i'm letting the ai play against the player, and it _usually_ works, but sometimes
when it's scoring moves, the is-grid-valid? assert in make-move gets triggered

found the bug. removing the is-grid-valid? assert drastically increases perf, which isn't
all that surprising, but i'd like to have it checked _somewhere_. maybe in quinto.mode

yeah cool i put it there
perf's looking good, especially in advanced mode

next up:
animate computer player's move
also briefly highlight their score when they make the move

DONE: let the player press a number key on their keyboard if they want to do that instead
of clicking on it

i thought i found a bug in the game's ai but it's just better at the game than i am

DONE let player make first move on an empty board

===========

12/21/17

DONE do another pass on the colors, they currently look bad
the green and red cells are good, everything else is bad
find something that lets you find colors that are the same, like, intensity as other colors?

DONE document quinto.modes

ok i guess i'm done?

XXXXX found a bug in scoring (and/or in the ai?)

i made this move

2
3
5
2
8

and then the computer made a move so the baord ended up like this

2
3
5
2 8
8 7

and the computer was given a score of 40 for that move

which is... correct.

8 + 2 = 10
8 + 7 = 15
8 + 7 = 15

nice

no bug!

=======

12/22/17

DONE clare requests a feature:
if you played the "optimal move" for your turn, draw that turn's score in a different color
there could be several moves tied for optimal, so just calculate the highest possible score
for your turn, and compare your actual score against that
will have to change how scores are represented

DONE if the player's starting hand doesn't contain a multiple of five, detect it and give them a new hand
i looked into this and it basically never happens, not even when i drew fifty thousand hands

DONE - rename escape-handler
DONE kill console.log in event loop

=======

1/2/18

DONE clare suggests having a this-is-how-much-your-move-will-be-worth readout when you're in assembling-move mode

DONE tentative-score coloration is misleading, needs to be gray if your move isn't valid

DONE: let the player hover over a past score to see what their optimal move would have been
new mode
keys :original-grid, :original-hand, :original-mode
display difference between moves as git diff does - red deletion, orange both-changed (but favor optimal), green added

DONE hover over computer scores to see what they played for that turn

DONE: randomize the starting player

DONE: ther'es a bug where the back button doesn't correctly handle the new you-can-change-selected-cell-more-often
code situation. fix it
maybe call select-cell in back button code, to avoid duplication

DONE left arrow preventdefault to avoid scrolling

DONE have red tentative-score numbers be up to date, not just the last valid score

HIGHEST PRIORITY
DONE add save_state console function so clare can serialize her app's state when she triggers a crash
maybe map it to the c key or something
or like tilde, i dunno

TODO add a win screen

TODO leaderboard (last 5-10 games stored locally)

TODO tutorial overlay

=========

1/3/18

zach ran into the crash clare saw when his board was like this

 7 8 0
     7
     7
     4
     2

doesn't repro locally though

DONE eleanore managed to make a first move with just a 4, which shouldn't happen - bug, fix

ok here's a dump of the state from a crashy game

{:grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil 7 nil nil nil nil nil nil nil] [nil nil nil nil nil 4 9 8 7 7 nil nil nil] [nil nil nil nil nil 9 1 7 8 nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]], :deck (4 2 4 1 5 9 2 7 8 8 8 2 0 1 2 9 0 7 9 3 7 9 1 0 7 7 5 9 8 7 3 0 4 2 7 0 7 4 4 5 3 5 8 3 9 1 8 3 0 9 7 8 0 8 8 4 9 9 1 4), :player-scores [{:value 9, :was-optimal false} {:value 20, :was-optimal false}], :player-hand (5 9 8 7 3), :ai-scores [{:value 35} {:value 65}], :ai-hand (4 2 4 3 5), :most-recent-computer-move #{[[7 6] 1] [[7 7] 7] [[7 8] 8]}, :mode {:mode/type :default}}

doesn't repro on my machine, not even in advanced mode
whyyy

"must satisfy ivector" only appears in subvec-related code
the only place i use subvec is specter
i think somewhere, a grid row or column is being turned into a seq rather than a vector?
or maybe it's nil?

========

1/4/18

probably a seq. can't get it to repro locally. coercing column to vector as a band-aid;
added a noisy alert that attempts to detect the issue and pr-strs the column if it manifests.
we'll see if that pops.

next up, let's fix that 4-first-move bug

TODO can we use a web worker to do the ai's move asynchronously?

TODO use css grid for scores, board, etc; figure out how to work ghost board in there

DONE think more about using :mode as a more formalized state machine; look up "your ui is a statechart" talk

========

1/5/18

have i found a bug?

on this board

        1
        2
9 9 3 7 7

i made this move

      4
      7
      4 1
      8 2
9 9 3 7 7

and scored 45 points. but the game is telling me that this move would have been optimal

        1
        2
9 9 3 7 7
    7 8 0

which looks to me like it would be a score of 35....
oh right.
main axis is worth an additional 15.
so that would have been 50 points.

no bug! game's better than i am!

TODO attempt to apply http://blog.cognitect.com/blog/2017/5/22/restate-your-ui-using-state-machines-to-simplify-user-interface-development

DONE holden's game got stuck in this state
{:grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil 8 1 8 8 nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]], :deck (2 7 7 0 3 3 7 1 9 1 9 3 2 8 3 9 8 5 0 5 1 3 1 8 0 4 9 7 9 8 1 8 4 2 5 0 7 7 4 9 3 0 4 2 7 4 0 9 7 8 7 4 8 2 4 7 5 9 4 9 9 7 3 9 7 5), :player-scores [], :player-hand (4 7 0), :ai-scores [{:value 25, :move #{[[6 6] 8] [[6 7] 1] [[6 8] 8] [[6 9] 8]}, :grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]]}], :ai-hand (4 8 8 5 2), :most-recent-computer-move [], :mode {:mode/type :viewing-historical-move, :move #{[[6 6] 8] [[6 7] 1] [[6 8] 8] [[6 9] 8]}, :optimal-move nil, :original-state {:grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil 7 9 nil nil nil nil nil] [nil nil nil nil nil nil 8 1 8 8 nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]], :deck (2 7 7 0 3 3 7 1 9 1 9 3 2 8 3 9 8 5 0 5 1 3 1 8 0 4 9 7 9 8 1 8 4 2 5 0 7 7 4 9 3 0 4 2 7 4 0 9 7 8 7 4 8 2 4 7 5 9 4 9 9 7 3 9 7 5), :player-scores [], :player-hand (4 7 0), :ai-scores [{:value 25, :move #{[[6 6] 8] [[6 7] 1] [[6 8] 8] [[6 9] 8]}, :grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]]}], :ai-hand (4 8 8 5 2), :most-recent-computer-move #{[[6 6] 8] [[6 7] 1] [[6 8] 8] [[6 9] 8]}, :mode {:mode/type :assembling-move, :selected-cell nil, :available-cells ([5 8] [5 5]), :move-so-far [[[5 6] 7] [[5 7] 9]], :tentative-score 41, :original-hand (4 9 7 7 0), :original-grid [[nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil 8 1 8 8 nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil] [nil nil nil nil nil nil nil nil nil nil nil nil nil]]}}}}

TODO we have two options for tracking down this bug:
DIDNT WORK OUT) generate a bunch of random moves (with spec?) and play them, add a js-debugger line where the alert is
2) remove this specter code in favor of the preexisting reduce

TODO the computer just made a first move whose value was 9!!!!! it was just the tile 9!

=====

1/6/18

TODO: take another stab at generating UI inputs, just using a random function like
(generate-next-ui-event last-ui-event)

ok this reliably triggers a crash with the same stacktrace (although it may not be completely the same crash):

(let [good-move (ai/pick-move (@app-state :grid) (@app-state :player-hand))]
    (swap! app-state assoc-in [:mode :move-so-far] good-move)
    (swap! app-state confirm-move))

this is because that code is incomplete - it doesn't set up a :mode :original-grid
so -find-runs gets called with a nil grid

so i guess the heisenbug happens when someone calls -find-runs with a nil grid
but when can that happen?

i'm gonna write the code to generate UI events now

ok, got that working, even in advanced mode
but the bug doesn't repro!
this only happens on other peoples' machines, not on mine
i think that the most likely explanation isn't that my computer is perfect
but instead that other people are somehow going through a state transition that i'm not thinking of
and didn't program into this UI-event-generator just now

so TODO:
look through all of the places where the game's state can be transitioned (except for historical mode)
and see if there's some transition in there that i haven't noticed that can cause the heisenbug behavior


